<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Return of the Cubes (2008â€“2025)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <style>
    body { margin:0; overflow:hidden; background:#111; touch-action:none; }
    #ui { position:absolute; top:10px; left:10px; color:#fff; z-index:10; background:rgba(0,0,0,0.5); padding:12px; border-radius:8px; font-family:Arial; }
    button { padding:12px 24px; font-size:18px; margin-top:8px; border:none; border-radius:6px; background:#555; color:#fff; }
    button:enabled { background:#08f; cursor:pointer; }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
  <div id="ui">
    <div style="font-size:24px;">Score: <span id="score">0</span> / <span id="target">1000</span></div>
    <div style="font-size:20px;">Level <span id="level">1</span></div>
    <button id="removeBtn" disabled>Remove Chain</button>
  </div>

  <script>
    const COLORS = [0xff3333, 0x33ff33, 0x4444ff, 0xffff33, 0xffaa00, 0xff33ff];
    const SIZE = 5, CELL = 1.1;
    let scene, camera, renderer, controls, cubes = [], selected = [];
    let score = 0, level = 1, target = 1000;

    function init() {
      scene = new THREE.Scene(); scene.background = new THREE.Color(0x111111);
      camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 100);
      camera.position.set(8, 8, 8); // Closer view for better face selection
      renderer = new THREE.WebGLRenderer({antialias:true});
      renderer.setSize(innerWidth, innerHeight);
      document.body.appendChild(renderer.domElement);
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.enablePan = false; // No panning/flying around
      controls.enableZoom = false; // No zoom
      controls.minDistance = 6; // Lock min zoom anyway
      controls.maxDistance = 6; // Lock max zoom
      scene.add(new THREE.AmbientLight(0xffffff, 0.6));
      scene.add(new THREE.DirectionalLight(0xffffff, 1.2)).position.set(5,10,7);
      createCube();
      window.addEventListener('resize', ()=>{camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth,innerHeight);});
      renderer.domElement.addEventListener('pointerdown', onPointerDown);
      document.getElementById('removeBtn').addEventListener('click', removeChain);
      animate();
    }

    function createCube() {
      cubes = []; selected = [];
      for(let x=0;x<SIZE;x++){ cubes[x]=[]; for(let y=0;y<SIZE;y++){ cubes[x][y]=[]; for(let z=0;z<SIZE;z++){
        const col = COLORS[Math.floor(Math.random()*6)];
        const mesh = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshLambertMaterial({color:col}));
        mesh.position.set((x-SIZE/2+0.5)*CELL, (y-SIZE/2+0.5)*CELL, (z-SIZE/2+0.5)*CELL);
        mesh.userData = {x,y,z,color:col,active:true};
        scene.add(mesh); cubes[x][y][z] = mesh;
      }}}
    }

    function onPointerDown(e) {
      const rect = renderer.domElement.getBoundingClientRect();
      const x = ((e.clientX||e.touches?.[0]?.clientX)-rect.left)/rect.width*2-1;
      const y = -((e.clientY||e.touches?.[0]?.clientY)-rect.top)/rect.height*2+1;
      const ray = new THREE.Raycaster();
      ray.setFromCamera({x,y}, camera);
      const hit = ray.intersectObjects(scene.children)[0];
      if (hit && hit.object.userData.active) selectCube(hit.object);
    }

    function selectCube(cube) {
      selected.forEach(c=>c.material.emissive.setHex(0));
      selected = [cube]; cube.material.emissive.setHex(0x666666);
      const queue = [cube], color = cube.userData.color, visited = new Set();
      while(queue.length){
        const cur = queue.pop(); if(visited.has(cur)) continue; visited.add(cur); selected.push(cur);
        cur.material.emissive.setHex(0x888888);
        const {x,y,z}=cur.userData;
        for(let dx=-1;dx<=1;dx++)for(let dy=-1;dy<=1;dy++)for(let dz=-1;dz<=1;dz++){
          if(Math.abs(dx) + Math.abs(dy) + Math.abs(dz) === 1){ // Orthogonal only, no diagonals, surface-like
            const nx=x+dx,ny=y+dy,nz=z+dz;
            if(nx>=0&&nx<SIZE&&ny>=0&&ny<SIZE&&nz>=0&&nz<SIZE){
              const n=cubes[nx][ny][nz];
              if(n&&n.userData.active&&n.userData.color===color&&!visited.has(n)) queue.push(n);
            }
          }
        }
      }
      document.getElementById('removeBtn').disabled = selected.length < 2;
    }

    function removeChain() {
      if(selected.length<2) return;
      const points = Math.pow(selected.length, selected.length-1);
      score += points; document.getElementById('score').textContent = score;

      // Pull-out animation
      selected.forEach(c=>{
        c.userData.active = false;
        c.material.transparent = true;
        c.material.opacity = 0;
      });

      setTimeout(applyGravity, 300);
      selected = [];
      document.getElementById('removeBtn').disabled = true;

      if(score >= target){
        level++; target = level*1000+500;
        document.getElementById('level').textContent = level;
        document.getElementById('target').textContent = target;
        setTimeout(createCube, 500);
      }
    }

    function applyGravity() {
      let moved;
      do {
        moved = false;
        for(let x=0;x<SIZE;x++) for(let z=0;z<SIZE;z++) for(let y=1;y<SIZE;y++){
          const cube = cubes[x][y][z];
          const below = cubes[x][y-1][z];
          if(cube.userData.active && !below.userData.active){
            cubes[x][y][z] = below; cubes[x][y-1][z] = cube;
            const tempY = cube.position.y;
            cube.position.y = below.position.y;
            below.position.y = tempY;
            moved = true;
          }
        }
      } while(moved);
    }

    function animate(){ requestAnimationFrame(animate); controls.update(); renderer.render(scene,camera); }
    init();
  </script>
</body>
</html>
