<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Return of the Cubes (2008–2025)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <style>
    body { margin:0; overflow:hidden; background:#000; touch-action:none; font-family:Arial, sans-serif; }
    #ui {
      position:absolute; top:10px; left:10px; color:white; z-index:10; background:rgba(0,0,0,0.4); padding:10px; border-radius:8px;
    }
    button { padding:12px 24px; font-size:18px; margin-top:10px; border:none; border-radius:6px; background:#555; color:white; }
    button:enabled { background:#0af; cursor:pointer; }
  </style>
</head>
<body>
  <div id="ui">
    <div style="font-size:24px;">Score: <span id="score">0</span> / <span id="target">1000</span></div>
    <div style="font-size:20px;">Level <span id="level">1</span></div>
    <button id="removeBtn" disabled>Remove Chain</button>
  </div>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.module.js';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/controls/OrbitControls.js';

    console.log('Cubes 2025 loaded – Three.js r' + THREE.REVISION);

    const COLORS = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff8800, 0xff00ff];
    const SIZE = 5;
    const CELL = 1.1;
    let scene, camera, renderer, controls;
    let cubes = [];
    let selected = [];
    let score = 0, level = 1, target = 1000;

    // ---------- INIT ----------
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);

    camera = new THREE.PerspectiveCamera(45, innerWidth / innerHeight, 0.1, 100);
    camera.position.set(10, 10, 10);

    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    scene.add(new THREE.DirectionalLight(0xffffff, 1.2)).position.set(5,10,7);

    createCube();
    window.addEventListener('resize', () => {
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
    renderer.domElement.addEventListener('pointerdown', onPointerDown);
    document.getElementById('removeBtn').addEventListener('click', removeChain);

    // ---------- CREATE 5×5×5 CUBE ----------
    function createCube() {
      for (let x = 0; x < SIZE; x++) {
        cubes[x] = [];
        for (let y = 0; y < SIZE; y++) {
          cubes[x][y] = [];
          for (let z = 0; z < SIZE; z++) {
            const color = COLORS[Math.floor(Math.random()*COLORS.length)];
            const mesh = new THREE.Mesh(
              new THREE.BoxGeometry(1,1,1),
              new THREE.MeshLambertMaterial({color})
            );
            mesh.position.set((x-SIZE/2+0.5)*CELL, (y-SIZE/2+0.5)*CELL, (z-SIZE/2+0.5)*CELL);
            mesh.userData = {x,y,z,color,active:true};
            scene.add(mesh);
            cubes[x][y][z] = mesh;
          }
        }
      }
    }

    // ---------- SELECTION & REMOVAL ----------
    function onPointerDown(e) {
      const rect = renderer.domElement.getBoundingClientRect();
      const x = ((e.clientX || e.touches?.[0]?.clientX) - rect.left)/rect.width*2-1;
      const y = -((e.clientY || e.touches?.[0]?.clientY) - rect.top)/rect.height*2+1;
      const ray = new THREE.Raycaster();
      ray.setFromCamera({x,y}, camera);
      const hits = ray.intersectObjects(scene.children);
      if (hits.length && hits[0].object.userData.active) selectCube(hits[0].object);
    }

    function selectCube(cube) {
      if (selected.includes(cube) && selected.length >= 2) { removeChain(); return; }
      selected.forEach(c=>c.material.emissive.setHex(0));
      selected = [cube];
      cube.material.emissive.setHex(0x888888);

      const queue = [cube];
      const color = cube.userData.color;
      const visited = new Set();
      while (queue.length) {
        const cur = queue.pop();
        if (visited.has(cur)) continue;
        visited.add(cur); selected.push(cur);
        cur.material.emissive.setHex(0x888888);
        const {x,y,z} = cur.userData;
        for (let dx=-1;dx<=1;dx++) for (let dy=-1;dy<=1;dy++) for (let dz=-1;dz<=1;dz++) {
          if (dx||dy||dz) {
            const nx=x+dx, ny=y+dy, nz=z+dz;
            if (nx>=0&&nx<SIZE&&ny>=0&&ny<SIZE&&nz>=0&&nz<SIZE) {
              const n = cubes[nx][ny][nz];
              if (n && n.userData.active && n.userData.color===color && !visited.has(n)) queue.push(n);
            }
          }
        }
      }
      document.getElementById('removeBtn').disabled = selected.length < 2;
    }

    function removeChain() {
      if (selected.length < 2) return;
      const points = Math.pow(selected.length, selected.length-1);
      score += points;
      document.getElementById('score').innerText = score;

      selected.forEach(c=>{ c.userData.active=false; c.material.transparent=true; c.material.opacity=0.3; });
      applyGravity();
      selected = [];
      document.getElementById('removeBtn').disabled = true;

      if (score >= target) {
        level++; target = level*1000 + 500;
        document.getElementById('level').innerText = level;
        document.getElementById('target').innerText = target;
      }
    }

    function applyGravity() {
      let moved;
      do {
        moved = false;
        for (let x=0;x<SIZE;x++) for (let z=0;z<SIZE;z++) for (let y=1;y<SIZE;y++) {
          const cube = cubes[x][y][z];
          const below = cubes[x][y-1][z];
          if (cube.userData.active && !below.userData.active) {
            [cubes[x][y][z], cubes[x][y-1][z]] = [below, cube];
            const tempY = cube.position.y;
            cube.position.y = below.position.y;
            below.position.y = tempY;
            moved = true;
          }
        }
      } while (moved);
    }

    // ---------- ANIMATION LOOP ----------
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
