<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Return of the Cubes (2008â€“2025)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <style>
    body { margin:0; overflow:hidden; background:#111; touch-action:none; font-family:Arial; }
    #ui { position:absolute; top:10px; left:10px; color:#fff; z-index:10; background:rgba(0,0,0,0.5); padding:12px; border-radius:8px; }
    button { padding:12px 24px; font-size:18px; margin-top:8px; border:none; border-radius:6px; background:#555; color:#fff; }
    button:enabled { background:#08f; cursor:pointer; }
  </style>
  <!-- Bundled Three.js + OrbitControls in one script -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script>
    THREE.OrbitControls = (function () {
      function OrbitControls(camera, domElement) {
        this.object = camera;
        this.domElement = domElement;
        this.enabled = true;
        this.target = new THREE.Vector3();
        this.minDistance = 0;
        this.maxDistance = Infinity;
        this.minZoom = 0;
        this.maxZoom = Infinity;
        this.minPolarAngle = 0;
        this.maxPolarAngle = Math.PI;
        this.minAzimuthAngle = -Infinity;
        this.maxAzimuthAngle = Infinity;
        this.enableDamping = false;
        this.dampingFactor = 0.05;
        this.enableZoom = false;
        this.enablePan = false;
        this.zoomSpeed = 1.0;
        this.rotateSpeed = 1.0;
        this.panSpeed = 1.0;
        this.screenSpacePanning = false;
        this.keyPanSpeed = 7.0;
        this.autoRotate = false;
        this.autoRotateSpeed = 2.0;
        this.keys = { LEFT: 'ArrowLeft', UP: 'ArrowUp', RIGHT: 'ArrowRight', BOTTOM: 'ArrowDown' };
        this.mouseButtons = { LEFT: THREE.MOUSE.ROTATE, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: THREE.MOUSE.PAN };
        this.touches = { ONE: THREE.TOUCH.ROTATE, TWO: THREE.TOUCH.DOLLY_PAN };
        this.target0 = this.target.clone();
        this.position0 = this.object.position.clone();
        this.zoom0 = this.object.zoom;
        this.getPolarAngle = function () { return 2 * Math.atan2(Math.sqrt(this.target.x * this.target.x + this.target.z * this.target.z), this.target.y) };
        this.getAzimuthalAngle = function () { return Math.atan2(this.target.x, this.target.z) };
        this.saveState = function () { this.target0.copy(this.target); this.position0.copy(this.object.position); this.zoom0 = this.object.zoom };
        this.reset = function () { this.target.copy(this.target0); this.object.position.copy(this.position0); this.object.zoom = this.zoom0; this.object.updateProjectionMatrix(); this.dispatchEvent({ type: 'change' }); this.update(); };
        this.update = function () { const position = this.object.position; const offset = position.clone().sub(this.target); const quat = new THREE.Quaternion().setFromUnitVectors(this.object.up, new THREE.Vector3(0, 1, 0)); const quatInverse = quat.clone().invert(); const euler = new THREE.Euler(0, 0, 0, 'XYZ'); const spherical = new THREE.Spherical(); spherical.setFromVector3(offset); spherical.theta += deltaX * this.rotateSpeed; spherical.phi += deltaY * this.rotateSpeed; spherical.theta = Math.max(this.minAzimuthAngle, Math.min(this.maxAzimuthAngle, spherical.theta)); spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, spherical.phi)); spherical.radius = Math.max(this.minDistance, Math.min(this.maxDistance, spherical.radius)); offset.setFromSpherical(spherical); offset.applyQuaternion(quatInverse); this.target.add(offset); this.object.lookAt(this.target); if (this.enableDamping === true) { deltaX *= (1 - this.dampingFactor); deltaY *= (1 - this.dampingFactor) } else { deltaX = 0; deltaY = 0 } this.dispatchEvent({ type: 'change' }); };
        this.dispose = function () { this.domElement.removeEventListener('contextmenu', onContextMenu, false); this.domElement.removeEventListener('pointerdown', onPointerDown, false); this.domElement.removeEventListener('wheel', onMouseWheel, false); this.domElement.removeEventListener('pointermove', onPointerMove, false); this.domElement.removeEventListener('pointerup', onPointerUp, false); window.removeEventListener('keydown', onKeyDown, false); };
        let deltaX = 0, deltaY = 0; let panOffset = new THREE.Vector3(); let offset = new THREE.Vector3(); let dollyStart = new THREE.Vector2(); let sphericalStart = new THREE.Spherical(); let state = STATE.NONE; const STATE = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_PAN: 4, TOUCH_DOLLY_PAN: 5, TOUCH_DOLLY_ROTATE: 6 }; function getAutoRotationDelta() { return 2 * Math.PI / 60 / 60 * this.autoRotateSpeed }; function getZoomScale() { return Math.pow(0.95, this.zoomSpeed) }; function rotateLeft(angle) { sphericalDelta.theta -= angle }; function rotateUp(angle) { sphericalDelta.phi += angle }; function panLeft(distance, objectMatrix) { panOffset.setFromMatrixColumn(objectMatrix, 0); panOffset.multiplyScalar(-distance); panOffset.add(this.target) }; function panUp(distance, objectMatrix) { panOffset.setFromMatrixColumn(objectMatrix, 1); panOffset.multiplyScalar(distance); panOffset.add(this.target) }; function pan(deltaX, deltaY) { const element = this.domElement; if (this.screenSpacePanning === true) { const camera = this.object; panOffset.setFromMatrixScale(camera.matrix); panOffset.multiplyScalar(0.001); } else { panOffset.setFromMatrixScale(this.object.matrix); panOffset.multiplyScalar(0.001); } panOffset.x = deltaX * panOffset.x; panOffset.y = deltaY * panOffset.y; this.target.add(panOffset) }; const onMouseDown = function (event) { if (this.enabled === false) return; event.preventDefault(); switch (event.button) { case 0: state = STATE.ROTATE; break; case 1: state = STATE.DOLLY; break; case 2: state = STATE.PAN; break; } dollyStart.set(event.clientX, event.clientY); sphericalStart.copy(spherical); }; const onMouseMove = function (event) { if (this.enabled === false) return; event.preventDefault(); switch (state) { case STATE.ROTATE: if (event.buttons === 1) { const e = event; const deltaX = e.clientX - dollyStart.x; const deltaY = e.clientY - dollyStart.y; rotateLeft(2 * Math.PI * deltaX / element.clientHeight * this.rotateSpeed); rotateUp(2 * Math.PI * deltaY / element.clientHeight * this.rotateSpeed); dollyStart.set(e.clientX, e.clientY); } break; case STATE.DOLLY: if (event.buttons === 1) { const e = event; dollyScale = Math.pow(getZoomScale(), event.clientY - dollyStart.y); dollyOut(getZoomScale()); dollyStart.set(e.clientX, e.clientY); } break; case STATE.PAN: if (event.buttons === 1) { const e = event; const deltaX = e.clientX - dollyStart.x; const deltaY = e.clientY - dollyStart.y; pan(deltaX, deltaY); dollyStart.set(e.clientX, e.clientY); } break; } }; const onMouseUp = function () { state = STATE.NONE }; const onMouseWheel = function (event) { if (this.enabled === false || this.enableZoom === false || state !== STATE.NONE) return; event.preventDefault(); if (event.deltaY < 0) { dollyOut(getZoomScale()); } else if (event.deltaY > 0) { dollyIn(getZoomScale()); } }; function dollyIn(dollyScale) { if (this.object.isPerspectiveCamera) { scale /= dollyScale } else { scale *= dollyScale } }; function dollyOut(dollyScale) { if (this.object.isPerspectiveCamera) { scale *= dollyScale } else { scale /= dollyScale } }; const onKeyDown = function (event) { if (this.enabled === false || this.enablePan === false) return; switch (event.code) { case this.keys.UP: pan(0, this.keyPanSpeed); this.update(); break; case this.keys.BOTTOM: pan(0, -this.keyPanSpeed); this.update(); break; case this.keys.LEFT: pan(this.keyPanSpeed, 0); this.update(); break; case this.keys.RIGHT: pan(-this.keyPanSpeed, 0); this.update(); break; } }; const onTouchStart = function (event) { if (this.enabled === false) return; switch (event.touches.length) { case 1: switch (this.touches.ONE) { case THREE.TOUCH.ROTATE: state = STATE.TOUCH_ROTATE; break; default: state = STATE.TOUCH_ROTATE; } break; case 2: switch (this.touches.TWO) { case THREE.TOUCH.DOLLY_PAN: state = STATE.TOUCH_DOLLY_PAN; break; case THREE.TOUCH.DOLLY_ROTATE: state = STATE.TOUCH_DOLLY_ROTATE; break; default: state = STATE.TOUCH_DOLLY_PAN; } break; default: state = STATE.NONE; } if (state !== STATE.NONE) { event.preventDefault(); } }; const onTouchMove = function (event) { if (this.enabled === false) return; event.preventDefault(); switch (event.touches.length) { case 1: switch (state) { case STATE.TOUCH_ROTATE: const x = event.touches[0].pageX - dollyStart.x; const y = event.touches[0].pageY - dollyStart.y; rotateLeft(2 * Math.PI * x / element.clientHeight * this.rotateSpeed); rotateUp(2 * Math.PI * y / element.clientHeight * this.rotateSpeed); dollyStart.set(event.touches[0].pageX, event.touches[0].pageY); break; default: state = STATE.TOUCH_ROTATE; } break; case 2: switch (state) { case STATE.TOUCH_DOLLY_PAN: const dx = event.touches[0].pageX - dollyStart.x; const dy = event.touches[0].pageY - dollyStart.y; const cx = event.touches[1].pageX - dollyStart.x; const cy = event.touches[1].pageY - dollyStart.y; const d = Math.sqrt(dx * dx + dy * dy); const c = Math.sqrt(cx * cx + cy * cy); dollyScale = getZoomScale(); const distance = d - c; dollyStart.set(event.touches[0].pageX, event.touches[0].pageY); break; default: state = STATE.TOUCH_DOLLY_PAN; } break; default: state = STATE.NONE; } }; const onTouchEnd = function () { state = STATE.NONE }; this.domElement.addEventListener('contextmenu', onContextMenu, false); this.domElement.addEventListener('pointerdown', onPointerDown, false); this.domElement.addEventListener('wheel', onMouseWheel, false); this.domElement.addEventListener('pointermove', onPointerMove, false); this.domElement.addEventListener('pointerup', onPointerUp, false); window.addEventListener('keydown', onKeyDown, false); this.domElement.addEventListener('touchstart', onTouchStart, false); this.domElement.addEventListener('touchend', onTouchEnd, false); this.domElement.addEventListener('touchmove', onTouchMove, false); this.update(); }
      OrbitControls.prototype = Object.create(THREE.EventDispatcher.prototype);
      OrbitControls.prototype.constructor = OrbitControls;
      return OrbitControls;
    })();
  </script>
</head>
<body>
  <div id="ui">
    <div style="font-size:24px;">Score: <span id="score">0</span> / <span id="target">1000</span></div>
    <div style="font-size:20px;">Level <span id="level">1</span></div>
    <button id="removeBtn" disabled>Remove Chain</button>
  </div>

  <script>
    const COLORS = [0xff3333, 0x33ff33, 0x4444ff, 0xffff33, 0xffaa00, 0xff33ff];
    const SIZE = 5, CELL = 1.1;
    let scene, camera, renderer, controls, cubes = [], selected = [];
    let score = 0, level = 1, target = 1000;

    function init() {
      scene = new THREE.Scene(); scene.background = new THREE.Color(0x111111);
      camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 100);
      camera.position.set(0, 0, 9);
      renderer = new THREE.WebGLRenderer({antialias:true});
      renderer.setSize(innerWidth, innerHeight);
      document.body.appendChild(renderer.domElement);
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.enablePan = false;
      controls.enableZoom = false;
      controls.target.set(0, 0, 0);
      scene.add(new THREE.AmbientLight(0xffffff, 0.6));
      scene.add(new THREE.DirectionalLight(0xffffff, 1.2)).position.set(5,10,7);
      createCube();
      window.addEventListener('resize', ()=>{camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth,innerHeight);});
      renderer.domElement.addEventListener('pointerdown', onPointerDown);
      document.getElementById('removeBtn').addEventListener('click', removeChain);
      animate();
    }

    function createCube() {
      cubes = []; selected = [];
      for(let x=0;x<SIZE;x++){ cubes[x]=[]; for(let y=0;y<SIZE;y++){ cubes[x][y]=[]; for(let z=0;z<SIZE;z++){
        const col = COLORS[Math.floor(Math.random()*6)];
        const mesh = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshLambertMaterial({color:col}));
        mesh.position.set((x-SIZE/2+0.5)*CELL, (y-SIZE/2+0.5)*CELL, (z-SIZE/2+0.5)*CELL);
        mesh.userData = {x,y,z,color:col,active:true};
        scene.add(mesh); cubes[x][y][z] = mesh;
      }}}
    }

    function onPointerDown(e) {
      const rect = renderer.domElement.getBoundingClientRect();
      const x = ((e.clientX||e.touches?.[0]?.clientX)-rect.left)/rect.width*2-1;
      const y = -((e.clientY||e.touches?.[0]?.clientY)-rect.top)/rect.height*2+1;
      const ray = new THREE.Raycaster();
      ray.setFromCamera({x,y}, camera);
      const hit = ray.intersectObjects(scene.children)[0];
      if (hit && hit.object.userData.active) selectCube(hit.object);
    }

    function selectCube(cube) {
      selected.forEach(c=>c.material.emissive.setHex(0));
      selected = [cube]; cube.material.emissive.setHex(0x666666);
      const queue = [cube], color = cube.userData.color, visited = new Set();
      while(queue.length){
        const cur = queue.pop(); if(visited.has(cur)) continue; visited.add(cur); selected.push(cur);
        cur.material.emissive.setHex(0x888888);
        const {x,y,z}=cur.userData;
        for(let dx=-1;dx<=1;dx++)for(let dy=-1;dy<=1;dy++)for(let dz=-1;dz<=1;dz++){
          if(Math.abs(dx) + Math.abs(dy) + Math.abs(dz) === 1){
            const nx=x+dx,ny=y+dy,nz=z+dz;
            if(nx>=0&&nx<SIZE&&ny>=0&&ny<SIZE&&nz>=0&&nz<SIZE){
              const n=cubes[nx][ny][nz];
              if(n&&n.userData.active&&n.userData.color===color&&!visited.has(n)) queue.push(n);
            }
          }
        }
      }
      document.getElementById('removeBtn').disabled = selected.length < 2;
    }

    function removeChain() {
      if(selected.length<2) return;
      const points = Math.pow(selected.length, selected.length-1);
      score += points; document.getElementById('score').textContent = score;

      selected.forEach(c=>{
        c.userData.active = false;
        c.material.transparent = true;
        c.material.opacity = 0;
      });

      setTimeout(applyGravity, 300);
      selected = [];
      document.getElementById('removeBtn').disabled = true;

      if(score >= target){
        level++; target = level*1000+500;
        document.getElementById('level').textContent = level;
        document.getElementById('target').textContent = target;
        setTimeout(createCube, 500);
      }
    }

    function applyGravity() {
      let moved;
      do {
        moved = false;
        for(let x=0;x<SIZE;x++) for(let z=0;z<SIZE;z++) for(let y=1;y<SIZE;y++){
          const cube = cubes[x][y][z];
          const below = cubes[x][y-1][z];
          if(cube.userData.active && !below.userData.active){
            cubes[x][y][z] = below; cubes[x][y-1][z] = cube;
            const tempY = cube.position.y;
            cube.position.y = below.position.y;
            below.position.y = tempY;
            moved = true;
          }
        }
      } while(moved);
    }

    function animate(){ requestAnimationFrame(animate); controls.update(); renderer.render(scene,camera); }
    init();
  </script>
</body>
</html>
