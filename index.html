<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Return of the Cubes (2008â€“2025)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <style>
    body { margin:0; overflow:hidden; background:#111; touch-action:none; font-family:Arial; }
    #ui { position:absolute; top:10px; left:10px; color:#fff; z-index:10; background:rgba(0,0,0,0.5); padding:12px; border-radius:8px; }
    button { padding:12px 24px; font-size:18px; margin-top:8px; border:none; border-radius:6px; background:#555; color:#fff; }
    button:enabled { background:#08f; cursor:pointer; }
    canvas { display:block; }
  </style>
</head>
<body>
  <div id="ui">
    <div style="font-size:24px;">Score: <span id="score">0</span> / <span id="target">1000</span></div>
    <div style="font-size:20px;">Level <span id="level">1</span></div>
    <button id="removeBtn" disabled>Remove Chain</button>
  </div>
  <canvas id="canvas"></canvas>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = innerWidth;
    canvas.height = innerHeight;
    const COLORS = ['#ff3333', '#33ff33', '#4444ff', '#ffff33', '#ffaa00', '#ff33ff'];
    const SIZE = 5;
    let cubes = [];
    let selected = [];
    let score = 0, level = 1, target = 1000;
    let angleX = 0, angleY = 0;
    let isDragging = false, lastX, lastY;

    function init() {
      createCube();
      canvas.addEventListener('pointerdown', onPointerDown);
      canvas.addEventListener('pointermove', onPointerMove);
      canvas.addEventListener('pointerup', onPointerUp);
      document.getElementById('removeBtn').addEventListener('click', removeChain);
      window.addEventListener('resize', () => {
        canvas.width = innerWidth;
        canvas.height = innerHeight;
      });
      animate();
    }

    function createCube() {
      cubes = [];
      for (let x = 0; x < SIZE; x++) {
        cubes[x] = [];
        for (let y = 0; y < SIZE; y++) {
          cubes[x][y] = [];
          for (let z = 0; z < SIZE; z++) {
            const color = COLORS[Math.floor(Math.random() * COLORS.length)];
            cubes[x][y][z] = { x, y, z, color, active: true };
          }
        }
      }
    }

    function onPointerDown(e) {
      isDragging = true;
      lastX = e.clientX;
      lastY = e.clientY;
      const rect = canvas.getBoundingClientRect();
      const mx = (e.clientX - rect.left) / canvas.width * 2 - 1;
      const my = - (e.clientY - rect.top) / canvas.height * 2 + 1;
      // Simple raycast simulation for 2D projection
      for (let x = 0; x < SIZE; x++) for (let y = 0; y < SIZE; y++) for (let z = 0; z < SIZE; z++) {
        const cube = cubes[x][y][z];
        if (cube.active) {
          const projX = (x - 2.5) * Math.cos(angleY) - (z - 2.5) * Math.sin(angleY);
          const projY = (y - 2.5) * Math.sin(angleX) + projX * Math.cos(angleX);
          if (Math.abs(projX - mx * 5) < 0.5 && Math.abs(projY - my * 5) < 0.5) {
            selectCube(cube, x, y, z);
            return;
          }
        }
      }
    }

    function onPointerMove(e) {
      if (!isDragging) return;
      const dx = e.clientX - lastX;
      const dy = e.clientY - lastY;
      angleY += dx * 0.01;
      angleX += dy * 0.01;
      lastX = e.clientX;
      lastY = e.clientY;
    }

    function onPointerUp() {
      isDragging = false;
    }

    function selectCube(cube, x, y, z) {
      selected = [{ cube, x, y, z }];
      // Flood fill orthogonal neighbors
      const queue = [{ cube, x, y, z }];
      const color = cube.color;
      const visited = new Set([`${x},${y},${z}`]);
      while (queue.length) {
        const { cube: cur, x: cx, y: cy, z: cz } = queue.pop();
        for (let dx = -1; dx <= 1; dx += 2) {
          const nx = cx + dx, ny = cy, nz = cz;
          if (nx >= 0 && nx < SIZE && cubes[nx][ny][nz].active && cubes[nx][ny][nz].color === color && !visited.has(`${nx},${ny},${nz}`)) {
            visited.add(`${nx},${ny},${nz}`);
            selected.push({ cube: cubes[nx][ny][nz], x: nx, y: ny, z: nz });
            queue.push({ cube: cubes[nx][ny][nz], x: nx, y: ny, z: nz });
          }
        }
        for (let dy = -1; dy <= 1; dy += 2) {
          const nx = cx, ny = cy + dy, nz = cz;
          if (ny >= 0 && ny < SIZE && cubes[nx][ny][nz].active && cubes[nx][ny][nz].color === color && !visited.has(`${nx},${ny},${nz}`)) {
            visited.add(`${nx},${ny},${nz}`);
            selected.push({ cube: cubes[nx][ny][nz], x: nx, y: ny, z: nz });
            queue.push({ cube: cubes[nx][ny][nz], x: nx, y: ny, z: nz });
          }
        }
        for (let dz = -1; dz <= 1; dz += 2) {
          const nx = cx, ny = cy, nz = cz + dz;
          if (nz >= 0 && nz < SIZE && cubes[nx][ny][nz].active && cubes[nx][ny][nz].color === color && !visited.has(`${nx},${ny},${nz}`)) {
            visited.add(`${nx},${ny},${nz}`);
            selected.push({ cube: cubes[nx][ny][nz], x: nx, y: ny, z: nz });
            queue.push({ cube: cubes[nx][ny][nz], x: nx, y: ny, z: nz });
          }
        }
      }
      document.getElementById('removeBtn').disabled = selected.length < 2;
    }

    function removeChain() {
      if (selected.length < 2) return;
      const points = Math.pow(selected.length, selected.length - 1);
      score += points;
      document.getElementById('score').textContent = score;

      selected.forEach(({ cube }) => { cube.active = false; });

      applyGravity();
      selected = [];
      document.getElementById('removeBtn').disabled = true;

      if (score >= target) {
        level++;
        target = level * 1000 + 500;
        document.getElementById('level').textContent = level;
        document.getElementById('target').textContent = target;
        setTimeout(createCube, 500);
      }
    }

    function applyGravity() {
      let moved;
      do {
        moved = false;
        for (let x = 0; x < SIZE; x++) for (let z = 0; z < SIZE; z++) for (let y = 1; y < SIZE; y++) {
          const cube = cubes[x][y][z];
          const below = cubes[x][y - 1][z];
          if (cube.active && !below.active) {
            cubes[x][y][z] = below;
            cubes[x][y - 1][z] = cube;
            moved = true;
          }
        }
      } while (moved);
    }

    function animate() {
      requestAnimationFrame(animate);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.save();
      ctx.translate(canvas.width / 2, canvas.height / 2);
      ctx.rotate(angleY);
      ctx.scale(1, Math.cos(angleX));
      for (let x = 0; x < SIZE; x++) for (let y = 0; y < SIZE; y++) for (let z = 0; z < SIZE; z++) {
        const cube = cubes[x][y][z];
        if (cube.active) {
          ctx.fillStyle = cube.color;
          ctx.fillRect((x - 2.5) * 40, (y - 2.5 + z - 2.5) * 40, 30, 30);
        }
      }
      ctx.restore();
    }

    init();
  </script>
</body>
</html>
